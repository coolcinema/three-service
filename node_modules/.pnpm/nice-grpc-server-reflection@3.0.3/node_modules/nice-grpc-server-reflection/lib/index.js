"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerReflectionService = void 0;
exports.ServerReflection = ServerReflection;
const nice_grpc_1 = require("nice-grpc");
const descriptor_pb_1 = require("google-protobuf/google/protobuf/descriptor_pb");
const reflection_pb_1 = require("./proto/grpc/reflection/v1/reflection_pb");
const google_protobuf_1 = require("google-protobuf");
var reflection_grpc_pb_1 = require("./proto/grpc/reflection/v1/reflection_grpc_pb");
Object.defineProperty(exports, "ServerReflectionService", { enumerable: true, get: function () { return reflection_grpc_pb_1.ServerReflectionService; } });
/**
 * Deserialization implementation of `google.protobuf.FileDescriptorSet` able
 * to track the source slice for each file.
 *
 * The deserialization logic is based on the protobuf definitions and the code
 * generated in the `google-protobuf` package.
 *
 * For each deserialized file descriptor, the source slice is attached to it
 * in the `fileSource` weakmap.
 */
function deserializeFileDescriptorSetWithFileSource(bytes, fileSource) {
    const reader = new google_protobuf_1.BinaryReader(bytes);
    const msg = new descriptor_pb_1.FileDescriptorSet();
    while (reader.nextField()) {
        if (reader.isEndGroup()) {
            break;
        }
        const field = reader.getFieldNumber();
        switch (field) {
            case 1: {
                const value = new descriptor_pb_1.FileDescriptorProto();
                // offset of the message start, null if the reader is never called
                let start = null;
                reader.readMessage(value, (msg, binaryReader) => {
                    if (start === null) {
                        start = binaryReader.getCursor();
                    }
                    return descriptor_pb_1.FileDescriptorProto.deserializeBinaryFromReader(msg, binaryReader);
                });
                const end = reader.getCursor();
                msg.addFile(value);
                if (start !== null && start <= end) {
                    fileSource.set(value, bytes.slice(start, end));
                }
                else {
                    throw new Error('Failed to retrieve file descriptor source slice: reader callback not called');
                }
                break;
            }
            default: {
                reader.skipField();
                break;
            }
        }
    }
    return msg;
}
/**
 * Implement the [`grpc.reflection.v1.ServerReflection`](https://github.com/grpc/grpc-proto/blob/master/grpc/reflection/v1/reflection.proto)
 * service for the provided file descriptor set.
 *
 * @param protoset Protobuf-encoded file descriptor set. This is a
 *   protobuf-encoded [google.protobuf.FileDescriptorSet](https://github.com/protocolbuffers/protobuf/blob/89c585602af7d28646ce92cd3abba07cfdad7fa6/src/google/protobuf/descriptor.proto#L56)
 *   value. It is usually generated by the protobuf compiler using the
 *   flag `--descriptor_set_out`. If using the option `fdProtoMode: "slice"`
 *   (default), this value is assumed to be an immutable `Uint8Array` value.
 *   If you can't guarantee immutability, clone the `protoset` value before
 *   passing it to this function (for example, using
 *   `Uint8Array.from(protoset)`).
 * @param serviceNames Allowlist specifying the full name of services to expose.
 *   An empty list means that no service will be exposed.
 */
function ServerReflection(protoset, serviceNames) {
    // Map from file descriptor values to their protobuf-encoded representation
    const fdBytes = new WeakMap();
    const fileDescriptorSet = deserializeFileDescriptorSetWithFileSource(protoset, fdBytes);
    function findSymbol(symbol, descriptor, prefix = '') {
        if (descriptor instanceof descriptor_pb_1.FileDescriptorProto) {
            const packageName = descriptor.getPackage();
            const packagePrefix = packageName == null ? '' : `${packageName}.`;
            return (descriptor
                .getMessageTypeList()
                .find(type => findSymbol(symbol, type, packagePrefix)) ||
                descriptor
                    .getEnumTypeList()
                    .find(type => findSymbol(symbol, type, packagePrefix)) ||
                descriptor
                    .getServiceList()
                    .find(type => findSymbol(symbol, type, packagePrefix)));
        }
        const fullName = prefix + descriptor.getName();
        if (symbol === fullName) {
            return descriptor;
        }
        if (descriptor instanceof descriptor_pb_1.DescriptorProto) {
            const messagePrefix = `${fullName}.`;
            return (descriptor
                .getNestedTypeList()
                .find(type => findSymbol(symbol, type, messagePrefix)) ||
                descriptor
                    .getEnumTypeList()
                    .find(type => findSymbol(symbol, type, messagePrefix)));
        }
        if (descriptor instanceof descriptor_pb_1.ServiceDescriptorProto) {
            const servicePrefix = `${fullName}.`;
            return descriptor
                .getMethodList()
                .find(method => findSymbol(symbol, method, servicePrefix));
        }
        return undefined;
    }
    function handleRequest(request) {
        switch (request.getMessageRequestCase()) {
            case reflection_pb_1.ServerReflectionRequest.MessageRequestCase.FILE_BY_FILENAME: {
                const filename = request.getFileByFilename();
                const fileDescriptorProto = fileDescriptorSet
                    .getFileList()
                    .find(file => file.getName() === filename);
                const fileDescriptorBytes = fileDescriptorProto !== undefined
                    ? fdBytes.get(fileDescriptorProto)
                    : undefined;
                if (fileDescriptorBytes == null) {
                    return new reflection_pb_1.ServerReflectionResponse().setErrorResponse(new reflection_pb_1.ErrorResponse()
                        .setErrorCode(nice_grpc_1.Status.NOT_FOUND)
                        .setErrorMessage(`File not found: ${filename}`));
                }
                return new reflection_pb_1.ServerReflectionResponse()
                    .setOriginalRequest(request)
                    .setFileDescriptorResponse(new reflection_pb_1.FileDescriptorResponse().setFileDescriptorProtoList([
                    fileDescriptorBytes,
                ]));
            }
            case reflection_pb_1.ServerReflectionRequest.MessageRequestCase.FILE_CONTAINING_SYMBOL: {
                const symbol = request.getFileContainingSymbol();
                const fileDescriptorProto = fileDescriptorSet
                    .getFileList()
                    .find(file => findSymbol(symbol, file) != null);
                const fileDescriptorBytes = fileDescriptorProto !== undefined
                    ? fdBytes.get(fileDescriptorProto)
                    : undefined;
                if (fileDescriptorBytes == null) {
                    return new reflection_pb_1.ServerReflectionResponse().setErrorResponse(new reflection_pb_1.ErrorResponse()
                        .setErrorCode(nice_grpc_1.Status.NOT_FOUND)
                        .setErrorMessage(`Symbol not found: ${symbol}`));
                }
                return new reflection_pb_1.ServerReflectionResponse()
                    .setOriginalRequest(request)
                    .setFileDescriptorResponse(new reflection_pb_1.FileDescriptorResponse().setFileDescriptorProtoList([
                    fileDescriptorBytes,
                ]));
            }
            case reflection_pb_1.ServerReflectionRequest.MessageRequestCase
                .FILE_CONTAINING_EXTENSION:
                {
                    const extensionRequest = request.getFileContainingExtension();
                    const containingType = extensionRequest.getContainingType();
                    const extensionNumber = extensionRequest.getExtensionNumber();
                    const fileDescriptorProto = fileDescriptorSet
                        .getFileList()
                        .find(file => {
                        const descriptor = findSymbol(containingType, file);
                        return (descriptor instanceof descriptor_pb_1.DescriptorProto &&
                            descriptor
                                .getExtensionList()
                                .some(extension => extensionNumber === extension.getNumber()));
                    });
                    const fileDescriptorBytes = fileDescriptorProto !== undefined
                        ? fdBytes.get(fileDescriptorProto)
                        : undefined;
                    if (fileDescriptorBytes == null) {
                        return new reflection_pb_1.ServerReflectionResponse().setErrorResponse(new reflection_pb_1.ErrorResponse()
                            .setErrorCode(nice_grpc_1.Status.NOT_FOUND)
                            .setErrorMessage(`Extension not found: ${containingType}(${extensionNumber})`));
                    }
                    return new reflection_pb_1.ServerReflectionResponse()
                        .setOriginalRequest(request)
                        .setFileDescriptorResponse(new reflection_pb_1.FileDescriptorResponse().setFileDescriptorProtoList([
                        fileDescriptorBytes,
                    ]));
                }
            case reflection_pb_1.ServerReflectionRequest.MessageRequestCase.LIST_SERVICES: {
                return new reflection_pb_1.ServerReflectionResponse()
                    .setOriginalRequest(request)
                    .setListServicesResponse(new reflection_pb_1.ListServiceResponse().setServiceList(serviceNames.map(serviceName => new reflection_pb_1.ServiceResponse().setName(serviceName))));
            }
            case reflection_pb_1.ServerReflectionRequest.MessageRequestCase
                .ALL_EXTENSION_NUMBERS_OF_TYPE:
                {
                    const type = request.getAllExtensionNumbersOfType();
                    return new reflection_pb_1.ServerReflectionResponse().setAllExtensionNumbersResponse(new reflection_pb_1.ExtensionNumberResponse().setBaseTypeName(type));
                }
        }
        return new reflection_pb_1.ServerReflectionResponse().setErrorResponse(new reflection_pb_1.ErrorResponse()
            .setErrorCode(nice_grpc_1.Status.UNIMPLEMENTED)
            .setErrorMessage('Not implemented'));
    }
    return {
        async *serverReflectionInfo(requests) {
            for await (const request of requests) {
                yield handleRequest(request);
            }
        },
    };
}
//# sourceMappingURL=index.js.map
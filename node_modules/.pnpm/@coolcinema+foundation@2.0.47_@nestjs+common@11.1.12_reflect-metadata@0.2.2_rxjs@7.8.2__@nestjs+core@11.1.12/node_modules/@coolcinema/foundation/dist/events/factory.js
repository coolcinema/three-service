"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createPublisher = createPublisher;
exports.createConsumer = createConsumer;
const store_1 = require("../context/store");
const keys_1 = require("../context/keys");
const propagator_1 = require("../context/propagator");
const INTERCEPT_HEADER = keys_1.CONTEXT_KEYS.TELEPRESENCE || "x-telepresence-intercept-id";
function createPublisher(transport, definition, prefix = "") {
    const channelWrapper = transport.getChannel();
    const publisher = {};
    for (const [methodKey, methodDef] of Object.entries(definition.methods)) {
        const logicalName = prefix ? `${prefix}.${methodDef.name}` : methodDef.name;
        const mainRouter = logicalName;
        const fallbackRouter = `${logicalName}.fallback`;
        channelWrapper.addSetup(async (channel) => {
            await channel.assertExchange(fallbackRouter, "topic", { durable: true });
            await channel.assertExchange(mainRouter, "headers", {
                durable: true,
                alternateExchange: fallbackRouter,
            });
        });
        publisher[methodKey] = async (payload) => {
            const headers = {};
            const ctx = (0, store_1.getCurrentContext)();
            propagator_1.Propagator.inject(ctx, (k, v) => {
                const val = Array.isArray(v) ? v[0] : v;
                headers[k] = val;
            });
            await channelWrapper.publish(mainRouter, "", payload, {
                headers: headers,
                contentType: "application/json",
                timestamp: Date.now(),
            });
        };
    }
    return publisher;
}
function createConsumer(transport, myServiceSlug) {
    const connection = transport.getChannel();
    const interceptId = process.env.TELEPRESENCE_INTERCEPT_ID || process.env.COOL_INTERCEPT_ID;
    return {
        subscribe: async (definition, methodName, sourcePrefix, handler) => {
            const methodDef = definition.methods[methodName];
            if (!methodDef)
                throw new Error(`Method ${String(methodName)} not found`);
            const logicalName = sourcePrefix
                ? `${sourcePrefix}.${methodDef.name}`
                : methodDef.name;
            const mainRouter = logicalName;
            const fallbackRouter = `${logicalName}.fallback`;
            await connection.addSetup(async (channel) => {
                await channel.assertExchange(fallbackRouter, "topic", {
                    durable: true,
                });
                await channel.assertExchange(mainRouter, "headers", {
                    durable: true,
                    alternateExchange: fallbackRouter,
                });
                let queueName;
                let sourceExchange;
                let bindArgs = {};
                if (interceptId) {
                    queueName = `${myServiceSlug}.${interceptId}.listen.${logicalName}`;
                    sourceExchange = mainRouter;
                    await channel.assertQueue(queueName, {
                        exclusive: true,
                        autoDelete: true,
                    });
                    bindArgs = {
                        "x-match": "all",
                        [INTERCEPT_HEADER]: interceptId,
                    };
                    await channel.bindQueue(queueName, sourceExchange, "", bindArgs);
                }
                else {
                    queueName = `${myServiceSlug}.listen.${logicalName}`;
                    sourceExchange = fallbackRouter;
                    await channel.assertQueue(queueName, { durable: true });
                    await channel.bindQueue(queueName, sourceExchange, "#");
                }
                await channel.consume(queueName, async (msg) => {
                    if (!msg)
                        return;
                    try {
                        const content = JSON.parse(msg.content.toString());
                        const headers = msg.properties.headers || {};
                        const traceId = headers[keys_1.CONTEXT_KEYS.TRACE_ID]?.toString();
                        const normalizedHeaders = {};
                        for (const [key, value] of Object.entries(headers)) {
                            if (Array.isArray(value))
                                normalizedHeaders[key] = value.map(String);
                            else if (value != null)
                                normalizedHeaders[key] = String(value);
                        }
                        const appCtx = { traceId, headers: normalizedHeaders };
                        await (0, store_1.runInContext)(appCtx, async () => {
                            await handler(content, appCtx);
                        });
                        channel.ack(msg);
                    }
                    catch (e) {
                        console.error(e);
                    }
                });
            });
        },
    };
}
//# sourceMappingURL=factory.js.map